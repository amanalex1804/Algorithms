/*
it will pay off
sooner or later..
*/


// to calculate sum over a query using segment tree
#include<bits/stdc++.h>
using namespace std;
#define siz 10000

int A[siz],tree[siz],val,ind,l,r;
void build(int st,int en,int nod)       //building the binary tree of segment tree
{
    if(st==en) tree[nod]=A[st];
    else
    {
        build(st,(en+st)/2,2*nod+1);
        build(((en+st)/2)+1,en,2*nod+2);
        tree[nod]=tree[2*nod+1]+tree[2*nod+2];           // 0 index tree
    }
}
void update(int st,int en,int nod)          //implementation is like binary search
{
    if(st==en)
    {
        A[st]+=val;
        tree[nod]+=val;
    }
    else
    {
        int mid=(st+en)/2;
        if(st<=ind and ind<=mid) update(st,mid,2*nod+1);
        else update(mid+1,en,2*nod+2);
        tree[nod]=tree[2*nod+1]+tree[2*nod+2];

    }
}
int query(int st,int en,int nod)
{
    if(r<st or en<l) return 0;       //the searching range lying completely outside
    if(l<=st and en<=r) return tree[nod];       //competely inside
    //for partially inside and outside

        int mid,p1,p2;
        mid=(st+en)/2;
        p1=query(st,mid,2*nod+1);
        p2=query(mid+1,en,2*nod+2);
        return (p1+p2);
}

int main()
{
    int n,i;
    cin>>n;
    for(i=0;i<n;++i) cin>>A[i];
    build(0,n-1,0);
    cout<<" the builded tree is\n";
    for(i=0;i<2*n-1;++i) cout<<tree[i]<<" ";
    cout<<endl;
    cout<<"enter the value and index of pos 0..n-1 \n";
    cin>>val>>ind;                            //this value is added to the the array NB: not replacing
    update(0,n-1,0);
    cout<<"the updated array and tree will be\n";
    for(i=0;i<n;++i) cout<<A[i]<<" ";
    cout<<endl;
    for(i=0;i<2*n-1;++i) cout<<tree[i]<<" ";
    cout<<endl;
    cout<<"enter the query (see the updated array)\n";
    cin>>l>>r;
    cout<<query(0,n-1,0);

    return 0;
}
